# Configuração do MirageJS para Mock de API

Este tutorial documenta como o MirageJS foi configurado no projeto para criar um servidor de API mock, permitindo o desenvolvimento e teste do frontend de forma independente do backend.

## 1. O que é o MirageJS?

MirageJS é uma biblioteca de mock de API que permite construir, testar e prototipar aplicações JavaScript sem depender de um backend real. Ele intercepta as requisições de rede feitas pela aplicação (ex: `fetch`, `axios`) e responde a elas como se fosse um servidor de verdade.

**Principais Vantagens:**
- **Desenvolvimento Paralelo:** O frontend pode ser desenvolvido sem esperar que a API real esteja pronta.
- **Testes Robustos:** Permite escrever testes de integração que simulam fluxos de usuário completos, incluindo requisições de rede.
- **Prototipação Rápida:** Facilita a criação de protótipos funcionais para demonstrações.
- **Ambiente Consistente:** Garante que os ambientes de desenvolvimento e teste se comportem da mesma maneira.

## 2. Instalação

As seguintes dependências de desenvolvimento foram instaladas:

```bash
npm install -D miragejs @faker-js/faker
```

- `miragejs`: A biblioteca principal.
- `@faker-js/faker`: Uma biblioteca poderosa para gerar dados falsos realistas (nomes, e-mails, CNPJs, etc.).

## 3. Estrutura de Diretórios Modular

Para garantir que a configuração do MirageJS seja organizada e escalável, foi criada a seguinte estrutura de diretórios dentro de `src/mirage`:

```
src/mirage/
├── factories/     # Lógica para gerar dados falsos (fábricas)
│   ├── company.ts
│   └── index.ts
├── models/        # Definição dos modelos de dados
│   ├── company.ts
│   └── index.ts
├── routes/        # Definição das rotas da API
│   ├── company.ts
│   └── index.ts
├── seeds/         # Dados iniciais para popular o "banco de dados"
│   └── index.ts
├── types.ts       # Tipos TypeScript para o servidor Mirage
└── index.ts       # Arquivo principal que monta e exporta o servidor
```

## 4. Detalhes da Implementação

### 4.1. Models (`src/mirage/models/`)

Define a "forma" dos dados. O arquivo `company.ts` define o modelo `Company`, e o `index.ts` exporta todos os modelos de forma centralizada.

```typescript
// src/mirage/models/company.ts
import { Model } from "miragejs";
export default Model.extend({});

// src/mirage/models/index.ts
import company from "./company";
export default { company };
```

### 4.2. Factories (`src/mirage/factories/`)

Usam o Faker.js para criar instâncias realistas dos modelos.

```typescript
// src/mirage/factories/company.ts
import { Factory } from "miragejs";
import { faker } from "@faker-js/faker";

export default Factory.extend({
  name() { return faker.company.name(); },
  cnpj() { return faker.string.numeric('##.###.###/####-##'); },
  email() { return faker.internet.email(); },
});
```

### 4.3. Rotas (`src/mirage/routes/`)

Aqui são definidas as rotas da API. A estrutura foi modularizada:

- **`company.ts`**: Contém as rotas específicas do recurso "company" (`GET /api/companies`, `POST /api/companies`).
- **`index.ts`**: É o roteador principal. Ele define o namespace (`/api`) e importa as rotas de outros módulos. Isso mantém o arquivo limpo e fácil de gerenciar.

```typescript
// src/mirage/routes/index.ts
import { Server } from "miragejs";
import type { AppRegistry } from "../types";
import companyRoutes from "./company";

export default function (this: Server<AppRegistry>) {
  this.namespace = "api";
  companyRoutes.call(this); // Chama as rotas de empresa
}
```

### 4.4. Seeds (`src/mirage/seeds/`)

Popula o banco de dados do Mirage com dados iniciais quando o servidor é iniciado. Ideal para ter dados para listar e testar assim que a aplicação carrega.

```typescript
// src/mirage/seeds/index.ts
import { Server } from "miragejs";

export default function (server: Server) {
  server.createList("company", 10); // Cria 10 empresas usando a factory
}
```

### 4.5. Tipagem (`src/mirage/types.ts`)

Para garantir a integração com o TypeScript, foi criado um tipo `AppRegistry` que informa ao MirageJS sobre todos os modelos e factories disponíveis. Isso permite um autocomplete e verificação de tipos excelentes.

```typescript
// src/mirage/types.ts
import type { Registry } from "miragejs";
import factories from "./factories";
import models from "./models";

export type AppRegistry = Registry<typeof models, typeof factories>;
```
**Nota:** Foi importante usar `import type` para evitar que o Vite tentasse importar um valor de runtime, o que causaria erros.

### 4.6. Servidor Principal (`src/mirage/index.ts`)

Este arquivo importa todas as partes (models, factories, rotas, seeds) e usa a função `createServer` do MirageJS para montar e exportar o servidor.

```typescript
// src/mirage/index.ts
import { createServer } from "miragejs";
import factories from "./factories";
import models from "./models";
import routes from "./routes";
import seeds from "./seeds";

export function makeServer({ environment = "development" } = {}) {
  return createServer({
    environment,
    models,
    factories,
    seeds,
    routes,
  });
}
```

## 5. Inicialização em Desenvolvimento

Para que o servidor mock seja executado apenas no ambiente de desenvolvimento, foi adicionada uma verificação no arquivo de entrada da aplicação, `src/main.tsx`.

```typescript
// src/main.tsx
import { makeServer } from './mirage';

if (process.env.NODE_ENV === 'development') {
  makeServer();
}
```

Isso garante que o código do MirageJS não seja incluído no build de produção, mantendo o bundle final limpo.